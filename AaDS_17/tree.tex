\section{Specification}

After lists, trees are the next most important data structure in computer science.
They can be seen as a generalization of lists where the elements are not arranged in a row, but branching is allowed.

\subsection{General Trees}

There are many equivalent definitions.
The easiest is by graphical example: A tree is something that looks like

\tikzstyle{node}=[circle,draw]
\begin{center}
\begin{tikzpicture}
\node[node] (0) at (0,0) {};
\node[node] (00) at (-2,-1) {};
\node[node] (01) at (0,-1) {};
\node[node] (02) at (2,-1) {};
\node[node] (000) at (-2,-2) {};
\node[node] (010) at (-1,-2) {};
\node[node] (011) at (1,-2) {};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (0) -- (02);
\draw[arrow] (00) -- (000);
\draw[arrow] (01) -- (010);
\draw[arrow] (01) -- (011);
\end{tikzpicture}
\end{center}

A more formal definition is this:

\begin{definition}[Tree]\label{def:ad:tree}
A \textbf{tree} is a connected directed graph in which
\begin{compactitem}
 \item there is exactly one node (called the \textbf{root}) with in-degree $0$,
 \item all other nodes have in-degree $1$.
\end{compactitem}
\end{definition}
Here we already used the more general concept of graphs, which we define formally in Sect.~\ref{sec:ad:graphs}.

Talking about the shape and parts of a tree can be confusing.
Therefore, we introduce some vocabulary that helps us:

\begin{definition}[Parts of a Tree]\label{def:ad:treeaux}
For every edge from $p$ to $c$, we call $p$ the \textbf{parent} of $c$ and $n$ a \textbf{child} of $p$.
Thus, the root has no parent; every non-root node has exactly one parent.
A node may have any number of children.
A node with $0$ children is called a \textbf{leaf}.
A node that is neither the root nor a child is called an \textbf{inner node}.

For every path from $a$ to $d$, we call $a$ an \textbf{ancestor} of $d$ and $d$ a \textbf{descendant} of $a$.
Thus, all nodes are descendants of the root
Every node is an ancestor/descendant of itself; a \textbf{proper} ancestor/descendant of $n$ is an ancestor/descendant that is not $n$.

The number of proper ancestors of $n$ is called the \textbf{depth} of $n$.
Thus, the root has depth $0$.

For a node $n$, the descendants of $n$ form a tree again, which has root $n$.
It is called the \textbf{subtree} at $n$.

A path from the root to a leaf is called a \textbf{branch}.
Thus, every leaf $l$ is part of exactly one branch, whose length is the depth of $l$.
The length of the longest branch(es) is called the \textbf{height} of the tree.
\end{definition}

Def.~\ref{def:ad:tree} only defines the abstract shape of trees.
But trees are only useful if we can store some data in each node.
For example, the following is a tree of integers:

\begin{center}
\begin{tikzpicture}
\node[node] (0) at (0,0) {5};
\node[node] (00) at (-2,-1) {3};
\node[node] (01) at (0,-1) {6};
\node[node] (02) at (2,-1) {1};
\node[node] (000) at (-2,-2) {0};
\node[node] (010) at (-1,-2) {6};
\node[node] (011) at (1,-2) {5};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (0) -- (02);
\draw[arrow] (00) -- (000);
\draw[arrow] (01) -- (010);
\draw[arrow] (01) -- (011);
\end{tikzpicture}
\end{center}

Once we store data in a tree, we have be a bit more careful: the order of children matters now.
For example, the above tree of integers is different from the tree of integers below even both are based on the same tree.

\begin{center}
\begin{tikzpicture}
\node[node] (0) at (0,0) {5};
\node[node] (00) at (-2,-1) {3};
\node[node] (01) at (0,-1) {6};
\node[node] (02) at (2,-1) {1};
\node[node] (000) at (-2,-2) {0};
\node[node] (010) at (-1,-2) {5};
\node[node] (011) at (1,-2) {6};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (0) -- (02);
\draw[arrow] (00) -- (000);
\draw[arrow] (01) -- (010);
\draw[arrow] (01) -- (011);
\end{tikzpicture}
\end{center}

Keeping track of the order makes the definition more complicated.
The following definition is one way possibility to define it formally:

\begin{definition}[Trees over a Set]\label{def:ad:labeledtree}
The set $Tree[A]$ contains the \textbf{trees over the set} $A$.
Such a tree over $A$ consists of
\begin{compactitem}
 \item a set $N$ (whose elements we call the nodes),
 \item a function $label:N\to A$ that maps nodes to elements of $A$ ($label(n)$ is called the label of $n$, it is the data stored in each node),
 \item a function $children:N\to N^*$ that maps every node to its list of children,
\end{compactitem}
such that $N$ and $children$ define a tree.
\end{definition}

\begin{remark}[Leaf-Labeled Trees]
$Tree[A]$ contains trees in which \emph{every} node stores data from $A$.
Occassionally, we are also interested in trees where only the \emph{leafs} are labeled.
And sometimes we need trees where inner nodes are labeled with elements of $A$ and leafs with elements of $B$.

We ignore those trees here.
But when working with someone else's tree data structures, it is important to check which nodes are labeled with what.
\end{remark}

\subsection{Binary Trees}

Binary trees are an important special case:

\begin{definition}[Binary Tree]\label{def:ad:bintree}
A \textbf{binary tree} is a tree in which all nodes have at most $2$ children.
If a node has $2$ children, they are called the \textbf{left} and \textbf{right} child.

Binary trees over a set are defined accordingly.

A binary tree is called \textbf{full} if all non-leaf nodes have exactly two children.
A full binary tree is called \textbf{complete} all all leafs have the same depth.
\end{definition}

For example, the following are, from left to right, a non-full, a full but not perfect, and a perfect binary tree of integers:
\begin{center}
\begin{tikzpicture}[scale=.7]
\node[node] (0) at (0,0) {5};
\node[node] (00) at (-2,-1) {3};
\node[node] (01) at (2,-1) {1};
\node[node] (010) at (1,-2) {6};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (01) -- (010);
\end{tikzpicture}
\tb\tb
\begin{tikzpicture}[scale=.7]
\node[node] (0) at (0,0) {5};
\node[node] (00) at (-2,-1) {3};
\node[node] (01) at (2,-1) {1};
\node[node] (010) at (1,-2) {6};
\node[node] (011) at (3,-2) {5};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (01) -- (010);
\draw[arrow] (01) -- (011);
\end{tikzpicture}
\tb\tb
\begin{tikzpicture}[scale=.7]
\node[node] (0) at (0,0) {5};
\node[node] (00) at (-2,-1) {3};
\node[node] (01) at (2,-1) {1};
\node[node] (000) at (-3,-2) {0};
\node[node] (001) at (-1,-2) {2};
\node[node] (010) at (1,-2) {6};
\node[node] (011) at (3,-2) {5};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (00) -- (000);
\draw[arrow] (00) -- (001);
\draw[arrow] (01) -- (010);
\draw[arrow] (01) -- (011);
\end{tikzpicture}
\end{center}


It is important to know the number of nodes in a binary tree:

\begin{theorem}\label{thm:ad:bintree}
A binary tree of height $h$ has at most $2^n$ nodes at depth $n$.
It has at most $2^{h+1}-1$ nodes in total.

If it is perfect, it has exactly $2^n$ nodes at depth $n$ and exactly $2^{h+1}-1$ nodes in total.
\end{theorem}
\begin{proof}
Exercise.
\end{proof}

In particular, the number of nodes grows exponentially with the depth.
Vice versa, we can organize $n$ nodes as a binary tree of height $\log_2 n$.
The latter property is often useful to obtain logarithmic implementations: if we organize $n$ elements in a (nearly) perfect binary tree, we can reach any element in $\log_2 n$ steps.

\subsection{Trees for Ordered Data}

\subsubsection{Binary Search Trees}

%\begin{definition}[Binary Search Trees]
%If $O$ is a total order on $A$, then $BST[A,O]$ is the subset of $Tree[A]$ containing only full binary trees in which ??? %needs optional left and optional right child
%\end{definition}



\subsubsection{Heaps}\label{sec:ad:heaps}

\begin{definition}[Heap]
If $O$ is a total order on $A$, then $Heap[A,O]$ is the subset of $Tree[A]$ containing only trees in which all branches are sorted with respect to $O$.
\end{definition}

The elements of $Heap[\Z,\leq]$ are also called \textbf{min-heaps}.
The elements of $Heap[\Z,\geq]$ are also called \textbf{max-heaps}.

The left tree below is a (binary) min-heap, the right one is neither a min-heap nor a max-heap:

\begin{center}
\begin{tikzpicture}
\node[node] (0) at (0,0) {5};
\node[node] (00) at (-2,-1) {12};
\node[node] (01) at (2,-1) {7};
\node[node] (010) at (1,-2) {12};
\node[node] (011) at (3,-2) {9};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (01) -- (010);
\draw[arrow] (01) -- (011);
\end{tikzpicture}
\tb\tb
\begin{tikzpicture}
\node[node] (0) at (0,0) {5};
\node[node] (00) at (-2,-1) {12};
\node[node] (01) at (2,-1) {3};
\node[node] (010) at (1,-2) {12};
\node[node] (011) at (3,-2) {4};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (01) -- (010);
\draw[arrow] (01) -- (011);
\end{tikzpicture}
\end{center}

In a heap, the every node is smaller than all its descendants.
The root is always the smallest element in the heap.
That makes heaps practical for sorting.
Applications are presented in Sect.~\ref{sec:ad:heaplists}.

\section{Data Structures}

Trees can be mutable or immutable.
However, trees are mostly used to store data.
Many algorithms work with a single mutable tree and insert data into it or delete data from it over time.

We consider two different data structures and use the following as an example tree
\begin{center}
\begin{tikzpicture}[scale=.7]
\node[node] (0) at (0,0) {5};
\node[node] (00) at (-2,-1) {3};
\node[node] (01) at (2,-1) {1};
\node[node] (010) at (1,-2) {6};
\draw[arrow] (0) -- (00);
\draw[arrow] (0) -- (01);
\draw[arrow] (01) -- (010);
\end{tikzpicture}
\end{center}

\subsection{Trees Using Lists}

The simplest data structure for trees uses lists:

\begin{acode}
\aclassI{Tree[A]}{data: A,\; children: List[Tree[A]]}{}{}
\end{acode}

The example tree is represented as
\[\anew{Tree[\Z]}{5,\; \big[\anew{Tree[\Z]}{3,Nil},\;\anew{Tree[\Z]}{1, [\anew{Tree[\Z]}{6,Nil}]}\big]}\].

\subsection{Trees Without Lists and With Null}

Some programmers or programming languages prefer a more awkward (but slightly less memory-intensive) data structure that does not use lists.

Here every node has two pointers: one to its first child and one to its next sibling:
\begin{acode}
\aclassI{Node[A]}{data: A,\; firstChild: Node[A], nextSibling: Node[A]}{}{}
\end{acode}
For leafs, the field $firstChild$ is $null$; for the last child of a node, the field $nextSibling$ is $null$.
It would be better not to use $null$. But programmers who use this data structure usually do not mind.

The example tree is represented as
\[\anew{Node[\Z]}{5,\; \anew{Tree[\Z]}{3,null, \;\anew{Tree[A]}{1, \anew{Tree[\Z]}{6,null,null}}, null}, null}\]

\section{Important Algorithms}

\subsection{Depth-First Search}

\subsection{Breadth-Frist Search}

\subsection{Min-Max Algorithm}

\section{Data Structures and Algotithms for Heaps}



\section{Search Trees}

Binary search trees and red-black trees are discussed in Sect.~\ref{sec:ad:sets}.

