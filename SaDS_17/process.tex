\section{Process Aspects}This section collects general methods that have been developed by practitioners to get a better handle on managing the software engineering process.They are generally very cheap and easy to deploy.Therefore, it should\footnote{It is not, though.} be considered gross\footnote{\emph{Gross} negligence is the kind that makes people liable to prosecution or litigation.} negligence to develop dependency-critical software without any one of these.However, training lacks behind with many current developers not updated on latest technologies.   \subsection{Coding Style}  There are many aspects of a program that have no semantic relevance.These include\begin{compactitem} \item most whitespace including   \begin{compactitem}    \item indentation and vertical alignment    \item tabs vs. spaces    \item placement of opening and closing brackets    \item optional spaces between operators and arguments   \end{compactitem}  \item choice of names for any names that are not fixed in the specification of the interface    \begin{compactitem}     \item private methods and field of a class     \item local variables of a function     \item classes and similar units that are not part of the specification    \end{compactitem}  \item syntactic restrictions on names including   \begin{compactitem}     \item length of names (documenting effect vs. readability)     \item capitalization of first character (e.g., lower case for values, upper case for types)     \item capitalization of inner characters (e.g., camel case vs. underscores)   \end{compactitem}  \item syntactic restrictions on declarations including   \begin{compactitem}     \item length of a method     \item number of declarations in a class     \item order of declarations (e.g., public vs. private, values vs. methods, mutable vs. immutable)   \end{compactitem}  \item formatting of structured documentation including   \begin{compactitem}     \item placement of documentation inside the comment     \item use of markdown syntax inside comments     \item presence and order of keywords (e.g., author, param, return)   \end{compactitem}   \item placement and formatting of comments containing verification-relevant information including   \begin{compactitem}     \item pre/postconditions of methods     \item class invariants     \item loop invariants     \item termination orderings for loops and recursive functions   \end{compactitem}\end{compactitem}  By standardizing these across a large project, readability is greatly enhanced.This is particularly important when it happens frequently that\begin{compactitem} \item new programmers join a team and have to be quickly retrained on the entire code base \item programmers move between teams \item different teams work on the same code\end{compactitem}Style checkers can be standalone or integrated into an IDE.Either way, they allow customizing a style and enforcing it throughout a project.Modern IDEs (e.g., IntelliJ) provide a wide variety of coding style configurations whose violation results in special warning.  \subsection{Documentation}Thorough documentation is used for multiple purposes:\begin{compactitem} \item tie the implementation to the specification (e.g., by referencing the exact page or item of the specification corresponding to a declaration) \item inform other programmers about functionality and important subtleties \item provide examples for how to instantiate a class or call a function \item automatically extract web pages containing API documentation \item attach verification-relevant information that can be automatically extracted by verifiers\end{compactitem}Most programming languages come with supporting tools that allow for structured documentation. For example, Javadoc is a structured documentation language for Java.The following example snippet is taken from the Javadoc home page:\begin{lstlisting}/** * Returns an Image object that can then be painted on the screen.  * The url argument must specify an absolute {@link URL}. The name * argument is a specifier that is relative to the url argument.  * <p> * This method always returns immediately, whether or not the  * image exists. When this applet attempts to draw the image on * the screen, the data will be loaded. The graphics primitives  * that draw the image will incrementally paint on the screen.  * * @param  url  an absolute URL giving the base location of the image * @param  name the location of the image, relative to the url argument * @return      the image at the specified URL * @see         Image */ public Image getImage(URL url, String name) {        try {            return getImage(new URL(url, name));        } catch (MalformedURLException e) {            return null;        } }\end{lstlisting}Note how it\begin{compactitem} \item uses \lstinline|/**| instead of the usual \lstinline|/*| to indicate a structured comment \item can link to other code parts (which requires some compilation knowledge to resolve relative references in the documentation) \item integrates HTML which is carried through to the generated web pages \item uses keywords like \lstinline|@param| so that better web pages can be produced \item is connected to the code by repeating the names of the function variables (which can be flagged by the style checker)\end{compactitem}\subsection{Versioning}Sophisticated version management systems like svn and recently git have tremendously improved the development process.Specifically, the use of git for the Linux kernel and the success of github have made a huge impact in the open source community.They allow\begin{compactitem} \item collaboration across physical distances \item maintaining different version of a software (e.g., a release and a development branch) \item retroactively determining when and by whom a bug was introduced \item automated building and testing on every commit\end{compactitem}The following article about google repository management is particularly interesting:\url{http://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext}\subsection{Code Review}Code review is the process of programmers reviewing each other's code before (or sometimes after) it becomes part of the stable parts of the code base.Many modern versioning tools simplify the process by\begin{compactitem} \item reifying changes (e.g., as diffs/patches or commits) so that each change can be reviewed and applied individually \item managing the available changes and applying them to branches \item maintain the proposed changes and the feedbacks and decisions by the reviewer\end{compactitem}Github's maintenance of git pull requests is a simple example of a systematic code review process.\subsection{Automated Building and Testing}Most commit-based software repositories allow for hooks that are executed automatically before or after every commit (called push in git).This is typically used for testing.A typical commit hook should\begin{compactitem} \item create a fresh checkout of the source code \item build the source \item run a test suite (where the test may be part of the source or provided externally)\end{compactitem}For most repository managers, automated build managers exist.They can generate reports for every commit and, e.g., alert users by emails upon new commits that fail the tests.A pre-commit hook can even reject the commit if the test failed.travis is a typical example.It is well-integrated with, e.g., github.\subsection{Issue-Tracking}Issue track is the systematic management of known problems, their discussion, and eventual solution.Usually an issue is maintained as a discussion thread, and all open issues are available in a list that allows for filtering and sorting.They are typically provided via web interfaces, in particular to allow users to easily submit issues.The typical process is\begin{compactenum} \item The initial post \textbf{opens} the issue. \item After some discussion, the issue is \textbf{assigned} to a programmer or team. \item After posting and checking the solution, the issue is \textbf{closed}.\end{compactenum}There is a wide variety of issue tracking systems, usually independent of the programming language.Many are integrated with wikis or versioned repositories.Examples are trac and github.\section{Programming Aspects}This section collects mostly independent practices for individual aspects of programming.\subsection{Input Validation and Internal Syntax}The following is a fundamental principle that is absolutely necessary when handling user input:\begin{compactitem} \item There is a data structure that represents the input/external syntax. This data structure is called the internal syntax. It should exactly follow the grammar of the input language.\footnote{Incidentally, this means that untyped languages are out} \item All processing proceeds in the following steps: \begin{enumerate} \item User input is parsed from a string holding external syntax into an object of type of the internal syntax.  The parser must be side-effect-free: It does not nothing but parse and return an object of the internal syntax or an error message.  Failure results in immediately rejecting the user input.  \item All processing that ever happens works with the internal syntax.  External syntax is never visible to any other function than the parser.  \item The data structure provides a printer (also called serializer) that turns it into a string.  Any output that is to be displayed to the user is generated in this way. \end{enumerate}\end{compactitem}It is desirable that parser and printer are exactly inverse to each other.However, it is common that certain aspects of the internal syntax are lost after parsing and printing (e.g., whitespace).However, no meaningful information should be lost, e.g., the parser should not insert default value for omitted optional arguments---instead, it must record that the argument was omitted.Conversely, parsing followed by printing must succeed and must result in the original object.Thus, we must have $parse(print(i))=i$ and ideally also $print(parse(e))=e$. \subsection{Common Bugs}\paragraph{Buffer and Array Bounds}\paragraph{Null Pointers}\paragraph{Casting}\subsection{Typing}\subsection{Safe by Design}\paragraph{Safe Defaults}\paragraph{Minimal Access Rights} \subsection{Minimal Interfaces}\section{Stability}% stable specification, workflows, policies